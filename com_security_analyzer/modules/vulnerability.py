# modules/vulnerability.py
"""
Vulnerability Analysis Module - Identifies potential security issues in COM objects
"""
import logging
import os
from typing import Dict, List, Optional
from dataclasses import dataclass

from ..core.base import BaseAnalyzer, AnalysisResult
from ..core.models import VulnerabilityLevel, COMObjectInfo, SecurityDescriptor

logger = logging.getLogger(__name__)

@dataclass
class Vulnerability:
    """Represents a discovered vulnerability"""
    name: str
    description: str
    level: VulnerabilityLevel
    component: str
    clsid: str
    remediation: str
    references: Optional[List[str]] = None

@dataclass
class VulnerabilityResult(AnalysisResult):
    """Results from vulnerability analysis"""
    findings: List[Vulnerability]

class VulnerabilityAnalyzer(BaseAnalyzer):
    """Analyzes COM objects for potential security vulnerabilities"""

    def analyze(self, previous_results: Dict[str, AnalysisResult]) -> Dict[str, VulnerabilityResult]:
        results = {}
        registry_data = previous_results.get('RegistryAnalyzer', {})
        security_data = previous_results.get('SecurityAnalyzer', {})
        method_data = previous_results.get('MethodDiscoveryAnalyzer', {})

        total_objects = len(registry_data)
        logger.info(f"Starting vulnerability analysis on {total_objects} COM objects")

        for clsid, reg_info in registry_data.items():
            findings = []
            
            # Check registry-based issues
            findings.extend(self._check_registry_issues(clsid, reg_info))
            
            # Check security-based issues if available
            if security_info := security_data.get(clsid):
                findings.extend(self._check_security_issues(clsid, security_info))
            
            # Check method-based issues if available
            if method_info := method_data.get(clsid):
                findings.extend(self._check_method_issues(clsid, method_info))
            
            if findings:
                results[clsid] = VulnerabilityResult(findings=findings)

        logger.info(f"Completed vulnerability analysis. Found issues in {len(results)} objects")
        return results

    def _check_registry_issues(self, clsid: str, reg_info: COMObjectInfo) -> List[Vulnerability]:
        """Check for registry-based vulnerabilities"""
        findings = []
        
        # Server path checks
        if server_path := reg_info.server_path:
            if self._is_path_writable(server_path):
                findings.append(Vulnerability(
                    name="Writable Server Path",
                    description=f"Server path '{server_path}' is writable by current user",
                    level=VulnerabilityLevel.CRITICAL,
                    component="Server Path",
                    clsid=clsid,
                    remediation="Restrict write permissions to administrators only",
                    references=["MS-COM: Server Security Requirements"]
                ))

            # Check if outside system directories
            sys_root = os.environ.get('SystemRoot', 'C:\\Windows')
            if not server_path.lower().startswith(sys_root.lower()):
                findings.append(Vulnerability(
                    name="Non-System Server Location",
                    description=f"Server located outside system directory: {server_path}",
                    level=VulnerabilityLevel.MEDIUM,
                    component="Server Path",
                    clsid=clsid,
                    remediation="Move server to protected system directory"
                ))

        # Threading model checks
        if reg_info.threading_model == 'Free':
            findings.append(Vulnerability(
                name="Unsafe Threading Model",
                description="COM object uses Free threading model",
                level=VulnerabilityLevel.LOW,
                component="Threading Model",
                clsid=clsid,
                remediation="Review thread safety implementation"
            ))

        return findings

    def _check_security_issues(self, clsid: str, sec_info: SecurityDescriptor) -> List[Vulnerability]:
        """Check for security descriptor and permission vulnerabilities"""
        findings = []
        dangerous_accounts = ['Everyone', 'Authenticated Users', 'Users', 'INTERACTIVE']
        
        # Check ownership
        if any(acct in sec_info.owner for acct in dangerous_accounts):
            findings.append(Vulnerability(
                name="Dangerous Owner",
                description=f"COM object owned by {sec_info.owner}",
                level=VulnerabilityLevel.HIGH,
                component="Security Descriptor",
                clsid=clsid,
                remediation="Change ownership to administrative account"
            ))

        # Check permissions
        for ace in sec_info.permissions:
            account = ace.get('account', '')
            rights = ace.get('rights', [])
            
            if any(acct in account for acct in dangerous_accounts):
                if 'WRITE_DAC' in rights or 'WRITE_OWNER' in rights:
                    findings.append(Vulnerability(
                        name="Critical Permission Assignment",
                        description=f"{account} has security descriptor modification rights",
                        level=VulnerabilityLevel.CRITICAL,
                        component="Security Permissions",
                        clsid=clsid,
                        remediation="Remove WRITE_DAC and WRITE_OWNER permissions"
                    ))
                elif 'KEY_SET_VALUE' in rights or 'KEY_CREATE_SUB_KEY' in rights:
                    findings.append(Vulnerability(
                        name="Dangerous Write Permission",
                        description=f"{account} has registry write permissions",
                        level=VulnerabilityLevel.HIGH,
                        component="Security Permissions",
                        clsid=clsid,
                        remediation="Remove write permissions for non-administrative accounts"
                    ))

        return findings

    def _check_method_issues(self, clsid: str, method_info: AnalysisResult) -> List[Vulnerability]:
        """Check for method-related vulnerabilities"""
        findings = []
        
        # Only process if methods were successfully analyzed
        if not getattr(method_info, 'accessible', False):
            return findings

        dangerous_patterns = {
            'execute': VulnerabilityLevel.HIGH,
            'run': VulnerabilityLevel.HIGH,
            'shell': VulnerabilityLevel.CRITICAL,
            'system': VulnerabilityLevel.HIGH,
            'create': VulnerabilityLevel.MEDIUM,
            'delete': VulnerabilityLevel.MEDIUM
        }

        for method in getattr(method_info, 'methods', []):
            method_name = method.name.lower()
            
            # Check for dangerous method names
            for pattern, level in dangerous_patterns.items():
                if pattern in method_name:
                    findings.append(Vulnerability(
                        name=f"Dangerous Method: {pattern}",
                        description=f"Method '{method.name}' matches dangerous pattern",
                        level=level,
                        component="Method",
                        clsid=clsid,
                        remediation="Review method implementation security"
                    ))

        return findings

    def _is_path_writable(self, path: str) -> bool:
        """Check if a file path is writable by the current user"""
        try:
            return os.access(path, os.W_OK)
        except Exception as e:
            logger.debug(f"Error checking path writability for {path}: {e}")
            return False